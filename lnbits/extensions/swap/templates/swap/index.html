{% extends "base.html" %} {% from "macros.jinja" import window_vars with context
%} {% block page %}
<div class="row q-col-gutter-md">
  <div class="col-12 col-md-8 col-lg-7 q-gutter-y-md">
    <q-card>
      <q-card-section>
        {% raw %}
        <h6 
          v-if="selectedAccount"
          class="text-subtitle1 q-my-none"
          style="text-align: center; margin: 4px;"
        >
          Address: {{ selectedAccount }}<br/>
          Balances: {{ userBalances }}
        </h6>
        {% endraw %}
        <q-btn unelevated color="primary" id="connectButton" @click="onConnect" :disabled="selectedAccount"
          >Connect Wallet</q-btn
        >
        <!-- :disabled="!selectedAccount" -->
        <q-btn unelevated color="primary"  @click="formDialog.show = true"
          >Create Swap</q-btn
        >
      </q-card-section>
    </q-card>
  </div>

  <div class="col-12 col-md-4 col-lg-5 q-gutter-y-md">
    <q-card>
      <q-card-section>
        <h6 class="text-subtitle1 q-my-none">
          {{SITE_TITLE}} swap extension
        </h6>
      </q-card-section>
      <q-card-section class="q-pa-none">
        <q-separator></q-separator>
        <q-list> {% include "swap/_api_docs.html" %} </q-list>
      </q-card-section>
    </q-card>
  </div>

  <div class="col-12 col-md-8 col-lg-7 q-gutter-y-md">
    <q-card>
      <q-card-section>
        <div class="row items-center no-wrap q-mb-md">
          <div class="col">
            <h5 class="text-subtitle1 q-my-none">Swaps</h5>
          </div>
          <div class="col-auto">
            <q-btn flat color="grey" @click="exportSubmarineSwapCSV"
              >Export to CSV</q-btn
            >
          </div>
        </div>
        <q-table
          dense
          flat
          :data="submarineSwaps"
          row-key="id"
          :columns="submarineSwapTable.columns"
          :pagination.sync="submarineSwapTable.pagination"
        >
          {% raw %}
          <template v-slot:header="props">
            <q-tr :props="props">
              <q-th auto-width></q-th>
              <q-th v-for="col in props.cols" :key="col.name" :props="props">
                {{ col.label }}
              </q-th>
            </q-tr>
          </template>
          <template v-slot:body="props">
            <q-tr :props="props">
              <q-td style="width: 10%">
                <q-btn
                  unelevated
                  dense
                  size="xs"
                  icon="visibility"
                  :color="($q.dark.isActive) ? 'grey-7' : 'grey-5'"
                  @click="openQrCodeDialog(props.row.id)"
                ></q-btn>
                <q-btn
                  unelevated
                  dense
                  size="xs"
                  icon="info"
                  :color="($q.dark.isActive) ? 'grey-7' : 'grey-5'"
                  @click="openStatusDialog(props.row.id)"
                ></q-btn>
                <q-btn
                  unelevated
                  dense
                  size="xs"
                  icon="flip_to_front"
                  :color="($q.dark.isActive) ? 'grey-7' : 'grey-5'"
                  @click="openMempool(props.row.id)"
                ></q-btn>
              </q-td>
              <q-td v-for="col in props.cols" :key="col.name" :props="props">
                {{ col.value }}
              </q-td>
            </q-tr>
          </template>
          {% endraw %}
        </q-table>
      </q-card-section>
    </q-card>
  </div>

  <div class="col-12 col-md-8 col-lg-7 q-gutter-y-md">
    <q-card>
      <q-card-section>
        <div class="row items-center no-wrap q-mb-md">
          <div class="col">
            <h5 class="text-subtitle1 q-my-none">Reverse Swaps</h5>
          </div>
          <div class="col-auto">
            <q-btn flat color="grey" @click="exportReverseSubmarineSwapCSV"
              >Export to CSV</q-btn>
          </div>
        </div>
        <q-table
          dense
          flat
          :data="reverseSubmarineSwaps"
          row-key="id"
          :columns="reverseSubmarineSwapTable.columns"
          :pagination.sync="reverseSubmarineSwapTable.pagination"
        >
          {% raw %}
          <template v-slot:header="props">
            <q-tr :props="props">
              <q-th auto-width></q-th>
              <q-th v-for="col in props.cols" :key="col.name" :props="props">
                {{ col.label }}
              </q-th>
            </q-tr>
          </template>
          <template v-slot:body="props">
            <q-tr :props="props">
              <q-td style="width: 10%">
                <q-btn
                  unelevated
                  dense
                  size="xs"
                  icon="info"
                  :color="($q.dark.isActive) ? 'grey-7' : 'grey-5'"
                  @click="openExplorer()"
                ></q-btn>
                <!-- <q-btn
                  unelevated
                  dense
                  size="xs"
                  icon="flip_to_front"
                  :color="($q.dark.isActive) ? 'grey-7' : 'grey-5'"
                  @click="openMempool(props.row.id)"
                ></q-btn> -->
              </q-td>
              <q-td v-for="col in props.cols" :key="col.name" :props="props">
                {{ col.value }}
              </q-td>
            </q-tr>
          </template>
          {% endraw %}
        </q-table>
      </q-card-section>
    </q-card>
  </div>

  <q-dialog v-model="formDialog.show" position="top">
    <q-card class="q-pa-lg q-pt-xl lnbits__dialog-card">
      <q-form @submit="createSwap" class="q-gutter-md">
        <q-select
          filled
          dense
          emit-value
          v-model="formDialog.data.wallet"
          :options="g.user.walletOptions"
          label="Wallet *"
        >
        </q-select>
        <div style="display: flex;">
          <q-select
            filled
            dense
            emit-value
            v-model="formDialog.data.base"
            style="flex: 1; margin-right: 2px;"
            :options="this.currencies"
            label="You Send"
          >
          </q-select>
          <q-input
            filled
            dense
            v-model.trim="formDialog.data.baseAmount"
            style="flex: 1;"
            type="number"
            step="any"
            label="Amount"
          ></q-input>
        </div>
        <div style="display: flex;">
          <q-select
            filled
            dense
            emit-value
            v-model="formDialog.data.quote"
            style="flex: 1; margin-right: 2px;"
            :options="this.currencies"
            label="You Receive"
          >
          </q-select>
          <q-input
            filled
            dense
            v-model.trim="formDialog.data.quoteAmount"
            style="flex: 1;"
            type="number"
            step="any"
            label="Amount"
          ></q-input>
        </div>
        <!-- <q-input
          filled
          dense
          v-model.trim="formDialog.data.memo"
          label="Title *"
          placeholder="LNbits paywall"
        ></q-input>
        <q-input
          filled
          dense
          autogrow
          v-model.trim="formDialog.data.description"
          label="Description"
        ></q-input>
        <q-input
          filled
          dense
          v-model.number="formDialog.data.amount"
          type="number"
          label="Amount (sat) *"
          hint="This is the minimum amount users can pay/donate."
        ></q-input>
        <q-list>
          <q-item tag="label" class="rounded-borders">
            <q-item-section avatar>
              <q-checkbox
                v-model="formDialog.data.remembers"
                color="primary"
              ></q-checkbox>
            </q-item-section>
            <q-item-section>
              <q-item-label>Remember payments</q-item-label>
              <q-item-label caption
                >A succesful payment will be registered in the browser's
                storage, so the user doesn't need to pay again to access the
                URL.</q-item-label
              >
            </q-item-section>
          </q-item>
        </q-list> -->
        <div class="row q-mt-lg">
          <q-btn
            unelevated
            color="primary"
            :disable="formDialog.data.baseAmount == null || formDialog.data.baseAmount < 0 || formDialog.data.quoteAmount == null || formDialog.data.quoteAmount < 0"
            type="submit"
            >Create Swap</q-btn
          >
          <q-btn v-close-popup flat color="grey" class="q-ml-auto"
            >Cancel</q-btn
          >
        </div>
      </q-form>
    </q-card>
  </q-dialog>
  <q-dialog v-model="qrCodeDialog.show" position="top">
    <q-card v-if="qrCodeDialog.data" class="q-pa-lg lnbits__dialog-card">
      <!-- <q-responsive :ratio="1" class="q-mx-xl q-mb-md">
        <qrcode
          :value="qrCodeDialog.data.bip21"
          :options="{width: 800}"
          class="rounded-borders"
        ></qrcode>
      </q-responsive> -->
      <div>
        {% raw %}
        <b>Lock onchain funds to the swap conract by clicking below button</b><br />
        <!-- <b>Expected amount (sats): </b>  {{ qrCodeDialog.data.expected_amount }} <br /> -->
        <b>Expected amount: </b>  {{ qrCodeDialog.data.expected_amount_btc }} <br />
        <!-- <b>Onchain Address: </b>  {{ qrCodeDialog.data.address }} <br /> -->
        {% endraw %}
      </div>
      <div class="row q-mt-lg q-gutter-sm">
        <!-- <q-btn
          outline
          color="grey"
          @click="copyText(qrCodeDialog.data.address, 'Onchain address copied to clipboard!')"
          class="q-ml-sm"
          >Copy On-Chain Address</q-btn
        > -->
        <q-btn
          outline
          color="grey"
          @click="lockFunds(qrCodeDialog.data.swap)"
          class="q-ml-sm"
          >Lock Funds</q-btn
        >
        <q-btn v-close-popup flat color="grey" class="q-ml-auto">Close</q-btn>
      </div>
    </q-card>
  </q-dialog>
  <q-dialog v-model="statusDialog.show" position="top">
    <q-card v-if="statusDialog.data" class="q-pa-lg lnbits__dialog-card">
      <div>
        {% raw %}
        <b>Boltz Status: </b>  {{ statusDialog.data.boltz }} <br />
        <b>Mempool Status: </b>  {{ statusDialog.data.mempool }} <br />
        <b>Blockheight timeout: </b>  {{ statusDialog.data.timeout_block_height }} <br />
        {% endraw %}
      </div>
      <div class="row q-mt-lg q-gutter-sm">
        <q-btn
          outline
          color="grey"
          @click="refundSwap(statusDialog.data.swap_id)"
          v-if="!statusDialog.data.reverse"
          class="q-ml-sm"
          >Refund</q-btn
        >
        <q-btn
          outline
          color="grey"
          @click="downloadRefundFile(statusDialog.data.swap_id)"
          v-if="!statusDialog.data.reverse"
          class="q-ml-sm"
          >Download refundfile</q-btn
        >
        <q-btn v-close-popup flat color="grey" class="q-ml-auto">Close</q-btn>
      </div>
    </q-card>
  </q-dialog>
  <q-dialog v-model="allStatusDialog.show" maximized position="top">
    <q-card v-if="allStatusDialog.data" class="q-pa-lg lnbits__dialog-card">
        <h4>pending swaps status</h4>
        <q-table
          dense
          flat
          :data="allStatusDialog.data.swaps"
          row-key="id"
          :columns="allStatusTable.columns"
          :rows-per-page-options="[0]"
        >
          {% raw %}
          <template v-slot:header="props">
            <q-tr :props="props">
              <q-th auto-width></q-th>
              <q-th v-for="col in props.cols" :key="col.name" :props="props">
                {{ col.label }}
              </q-th>
            </q-tr>
          </template>
          <template v-slot:body="props">
            <q-tr :props="props">
              <q-td style="width: 10%">
                <q-btn
                  unelevated
                  dense
                  size="xs"
                  icon="cached"
                  :color="($q.dark.isActive) ? 'grey-7' : 'grey-5'"
                  @click="refundSwap(props.row.swap_id)"
                ></q-btn>
                <q-btn
                  unelevated
                  dense
                  size="xs"
                  icon="download"
                  :color="($q.dark.isActive) ? 'grey-7' : 'grey-5'"
                  @click="downloadRefundFile(props.row.swap_id)"
                ></q-btn>
                <q-btn
                  unelevated
                  dense
                  size="xs"
                  icon="flip_to_front"
                  :color="($q.dark.isActive) ? 'grey-7' : 'grey-5'"
                  @click="openMempool(props.row.swap_id)"
                ></q-btn>
              </q-td>
              <q-td v-for="col in props.cols" :key="col.name" :props="props">
                {{ col.value }}
              </q-td>
            </q-tr>
          </template>
          {% endraw %}
        </q-table>
      <div class="row q-mt-lg q-gutter-sm">
        <q-btn v-close-popup flat color="grey" class="q-ml-auto">Close</q-btn>
      </div>
    </q-card>
  </q-dialog>
</div>
{% endblock %} {% block scripts %} {{ window_vars(user) }}
<script type="text/javascript" src="https://unpkg.com/web3@1.2.11/dist/web3.min.js"></script>
<script type="text/javascript" src="https://unpkg.com/web3modal@1.9.0/dist/index.js"></script>
<script type="text/javascript" src="https://unpkg.com/evm-chains@0.2.0/dist/umd/index.min.js"></script>
<script type="text/javascript" src="https://unpkg.com/@walletconnect/web3-provider@1.2.1/dist/umd/index.min.js"></script>
<script type="text/javascript" src="https://unpkg.com/fortmatic@2.0.6/dist/fortmatic.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ethereumjs/browser-builds/dist/ethereumjs-tx/ethereumjs-tx-1.3.3.min.js"></script>
<script src="https://unpkg.com/bn.js@5.2.1/lib/bn.js"></script>
<script src="https://unpkg.com/bignumber.js"></script>
<!-- <script src="/swap/static/js/bolt11.js"></script> -->
<script src="/swap/static/js/abi.js"></script>
<script>
  // Vue.component(VueQrcode.name, VueQrcode)
  new Vue({
    el: '#vue',
    mixins: [windowMixin],
    data: function () {
      return {
        tools: [],
        formDialog: {
          show: false,
          data: {
            remembers: false,
            instant_settlement: true,
          }
        },
        web3Modal: null,
        web3: null,
        provider: null,
        selectedAccount: null,
        userBalances: {},
        boltzApi: '',
        currencies: null,
        rates: null,
        limits: null,
        fees: null,
        explorerLink: 'https://explorer.rsk.co',
        // boltz extension vars
        mempool: "",
        boltzConfig: {},
        submarineSwaps: [],
        reverseSubmarineSwaps: [],
        statuses: [],
        submarineSwapDialog: {
          show: false,
          data: {
            amount: 10000,
          }
        },
        reverseSubmarineSwapDialog: {
          show: false,
          data: {
            amount: 10000,
            instant_settlement: true,
          }
        },
        qrCodeDialog: {
          show: false,
          data: {}
        },
        statusDialog: {
          show: false,
          data: {}
        },
        allStatusDialog: {
          show: false,
          data: {}
        },
        allStatusTable: {
          columns: [
            {
              name: 'swap_id',
              align: 'left',
              label: 'swap_id',
              field: 'swap_id'
            },
            {
              name: 'status',
              align: 'left',
              label: 'status',
              field: 'status'
            },
            {
              name: 'boltz',
              align: 'left',
              label: 'boltz',
              field: 'boltz'
            },
            {
              name: 'mempool',
              align: 'left',
              label: 'mempool',
              field: 'mempool'
            },
            {
              name: 'timeout_block_height',
              align: 'left',
              label: 'block height',
              field: 'timeout_block_height'
            }
          ],
          pagination: {
            rowsPerPage: 10
          }
        },
        reverseSubmarineSwapTable: {
          columns: [
            {
              name: 'time',
              align: 'left',
              label: 'time',
              field: 'time',
              sortable: true,
              format: function(val, row) {
                return new Date(val * 1000).toUTCString();
              },
            },
            {
              name: 'status',
              align: 'left',
              label: 'status',
              field: 'status'
            },
            {
              name: 'boltz_id',
              align: 'left',
              label: 'boltz id',
              field: 'boltz_id'
            },
            {
              name: 'onchain_amount',
              align: 'left',
              label: 'onchain amount',
              field: 'onchain_amount'
            },
            {
              name: 'timeout_block_height',
              align: 'left',
              label: 'timeout block height',
              field: 'timeout_block_height'
            }
          ],
          pagination: {
            rowsPerPage: 10
          }
        },
        submarineSwapTable: {
          columns: [
            {
              name: 'time',
              align: 'left',
              label: 'time',
              field: 'time',
              sortable: true,
              format: function(val, row) {
                return new Date(val * 1000).toUTCString();
              },
            },
            {
              name: 'status',
              align: 'left',
              label: 'status',
              field: 'status'
            },
            {
              name: 'boltz_id',
              align: 'left',
              label: 'boltz id',
              field: 'boltz_id'
            },
            {
              name: 'expected_amount',
              align: 'left',
              label: 'expected amount',
              field: 'expected_amount'
            },
            {
              name: 'timeout_block_height',
              align: 'left',
              label: 'timeout block height',
              field: 'timeout_block_height'
            }
          ],
          pagination: {
            rowsPerPage: 10
          }
        },
      }
    },
    watch: {
      'formDialog.data.baseAmount'(newAmount, oldAmount) {
        // console.log('watch baseAmount ', oldAmount, newAmount)
        // console.log('rates, this.formDialog.data ', this.rates, this.formDialog.data, `${this.sanitizeCurrency(this.formDialog.data.base)}/${this.formDialog.data.quote}`)
        if (!this.formDialog.data.base || !this.formDialog.data.quote) return
        this.formDialog.data.quoteAmount = this.rates[`${this.sanitizeCurrency(this.formDialog.data.base)}/${this.sanitizeCurrency(this.formDialog.data.quote)}`]['rate']*newAmount
      },
      'formDialog.data.quoteAmount'(newAmount, oldAmount) {
        // console.log('watch quoteAmount ', newAmount, oldAmount)
        // console.log('rates, this.formDialog.data, ', this.rates, this.formDialog.data, `${this.formDialog.data.quote}/${this.formDialog.data.base}`)
        if (!this.formDialog.data.base || !this.formDialog.data.quote) return
        this.formDialog.data.baseAmount = this.rates[`${this.sanitizeCurrency(this.formDialog.data.quote)}/${this.sanitizeCurrency(this.formDialog.data.base)}`]['rate']*newAmount
      }
    },
    created: async function () {
      var self = this

      await this.getBoltzUrl()
      this.initScripts()
      this.getPairs()

      this.getSubmarineSwap();
      this.getReverseSubmarineSwap();
    },
    methods: {
      lockFunds: async function (swap) {
        console.log('lockFunds ', swap)
        const web3 = new Web3(this.provider)

        // var decoded = decode(swap.invoice);
        // // console.log("decoded: ", decoded);

        // var obj = decoded.tags;
        // for (let index = 0; index < obj.length; index++) {
        //   const tag = obj[index];
        //   // console.log("tag: ", tag);
        //   if (tag.tagName == 'payment_hash') {
        //     console.log('yay: ', tag.data);
        //     var paymenthash = tag.data;
        //   }
        // }
        // console.log('paymenthash: ', swap.payment_hash);

        // const preimageHash = getHexBuffer(paymenthash);
        // var preimageHashbuffer = Buffer.from(paymenthash, 'hex');
        const preimageHashbuffer = await this.getHexBuffer(swap.payment_hash);
        console.log('getHexBuffer preimageHash ', swap.payment_hash);
        console.log('preimageHashbuffer ', preimageHashbuffer);
        const amount = new BN(swap.expected_amount).mul(etherDecimals);
        console.log('amount ', amount);

        const timeout = web3.utils.numberToHex(swap.timeout_block_height);
        console.log('timeout ', timeout);

        console.log(
          'web3.eth.accounts.currentProvider.selectedAddress ',
          web3.eth.accounts.currentProvider.selectedAddress
        );

        // rbtcswapaddress
        var rbtcswapcontract = new web3.eth.Contract(
          rbtcswapabi,
          swap.address
        );
        console.log(
          'rbtc locking with ',
          preimageHashbuffer,
          swap.claim_address.toLowerCase(),
          timeout,
          'to contract ',
          swap.address
        );
        // , chainId: 33
        rbtcswapcontract.methods
          .lock(preimageHashbuffer, swap.claim_address.toLowerCase(), timeout)
          .send(
            {
              from: web3.eth.accounts.currentProvider.selectedAddress,
              value: amount,
            },
            function(error, transactionHash) {
              console.log('error: ', error);
              console.log('transactionHash: ', transactionHash);
              this.qrCodeDialog.show = false
            }
          );
      },
      claimFunds: async function (swapInfo, swapResponse) {
        console.log('claimFunds ', swapInfo)
        const preimage = swapInfo.preimage
        const preimageBuffer = await this.getHexBuffer(swapInfo.preimage);
        // Buffer.from(preimage, 'hex');
        // console.log("getHexBuffer preimage ", paymenthash)
        console.log('preimageBuffer ', preimageBuffer);
        // swapResponse.onchainAmount
        const amount = new BN(swapInfo.onchain_amount).mul(etherDecimals);
        console.log('amount ', amount);

        const web3 = new Web3(this.provider)
        // console.log('got web3 ', web3)
        const timeout = web3.utils.numberToHex(swapInfo.timeout_block_height);
        // console.log('timeout ', timeout);

        // console.log(
        //   'web3.eth.accounts.currentProvider.selectedAddress ',
        //   web3.eth.accounts.currentProvider.selectedAddress
        // );

        // rbtcswapaddress
        var rbtcswapcontract = new web3.eth.Contract(
          rbtcswapabi,
          swapInfo.lockup_address
        );
        console.log(
          'rbtc claiming with ',
          preimageBuffer,
          amount,
          swapInfo.refund_address,
          timeout,
          ' from contract ',
          swapInfo.lockup_address
        );
        // , chainId: 33
        let lastBlockGasLimit = web3.eth.getBlock('latest').gasLimit || 0;
        let gasLimit = Math.max(lastBlockGasLimit, 100000);
        console.log('lastBlockGasLimit, gasLimit: ', lastBlockGasLimit, gasLimit);
        rbtcswapcontract.methods
          .claim(preimageBuffer, amount, swapInfo.refund_address, timeout)
          .send(
            {
              from: this.selectedAccount,
              gas: gasLimit,
            },
            function(error, transactionHash) {
              console.log('error: ', error);
              console.log('transactionHash: ', transactionHash);
            }
          );
      },
      startListening: function (swap) {
        const source = new EventSource(
          `${this.boltzApi}/streamswapstatus?id=${swap.boltz_id}`
        );
        source.onerror = () => {
          source.close();
          console.log(`Lost connection to backend`);
          const url = `${this.boltzApi}/swapstatus`;

          const interval = setInterval(() => {
            axios
              .post(url, {
                id: swap.boltz_id,
              })
              .then(statusReponse => {
                clearInterval(interval);
                console.log(`Reconnected to backend`);
                this.startListening(
                  swap.boltz_id
                );

                this.handleSwapStatus(swap,
                  statusReponse.data,
                );
              });
          }, 1000)
        }
        source.onmessage = event => {
          this.handleSwapStatus(swap,
            JSON.parse(event.data),
          );
        };
      },
      handleSwapStatus: function (swap, swapStatus) {
        console.log('handleReverseSwapStatus' , swap, swapStatus)
        switch (swapStatus.status) {
          case 'transaction.confirmed':
            if (swap.preimage) {
              // ready to claim for reverseswap
              this.claimFunds(swap)
            }
            break;
          case 'invoice.settled':
            this.$q.notify({
              message: `Swap is successful!`,
              timeout: 1000,
              type: 'positive',
            })
            // update the table
            setTimeout(() => {
              this.getReverseSubmarineSwap()
              this.getSubmarineSwap()
            }, 1000)
            break;
        
          default:
            break;
        }
      },
      createSwap: async function () {
        // checks
        if ((this.formDialog.data.base === this.formDialog.data.quote) || !this.selectedAccount) {
          this.$q.notify({
            message: `Please fix input parameters and try again.`,
            timeout: 1000
          })
        }

        let wallet = _.findWhere(this.g.user.wallets, {
          id: this.formDialog.data.wallet
        })
        let data = this.formDialog.data
        // data.wallet = wallet
        data.claimAddress = this.selectedAccount
        // convert sats -> BTC
        let swap;
        if(this.formDialog.data.base.includes('⚡')) {
          // user sends ⚡ -> reverse submarine swap
          data.amount = this.formDialog.data.baseAmount
          swap = await this.createReverseSubmarineSwap(wallet, data)
          console.log('createReverseSubmarineSwap wallet, data, swap', wallet, data, swap)
        } else {
          data.amount = this.formDialog.data.quoteAmount
          swap = await this.createSubmarineSwap(wallet, data)
          console.log('createSubmarineSwap wallet, data, swap', wallet, data, swap)
        }
        if(swap) {
          this.formDialog.show = false
          this.startListening(swap)
        }
        
        
        // if (data.id) {
        //   this.updateSwapOut(wallet, data)
        // } else {
          // this.createSubmarineSwap(wallet, data)
        // }
      },
      // updateBaseAmount: function () {
      //   const quoteAmount = this.quoteAmount
      //   const quote = this.formDialog.data.quote
      //   console.log('rates, quote, quoteamount ', this.rates, quote, quoteAmount)
      // },
      // updateQuoteAmount: function () {
      //   const baseAmount = this.baseAmount
      //   const base = this.formDialog.data.base
      //   console.log('rates, base, baseamount ', this.rates, base, baseAmount)
      // },
      sanitizeCurrency: function(currency) {
        if (currency === 'BTC ⚡') return 'BTC'
        return currency
      },
      getHexBuffer: async input => {
        // let url = '/swap/api/v1/gethexbuffer/'+input
        // return await LNbits.api.request('GET', url)
        return ethereumjs.Buffer.Buffer.from(input,'hex');
        // return Buffer.from(input, 'hex');
      },
      getPairs: async function () {
        const url = `${this.boltzApi}/getpairs`
        console.log('getPairs from boltz API: ', `${this.boltzApi}/getpairs`)
        try {
          const response = await axios.get(url)
          const { warnings, pairs } = response.data
          console.log('got pairs ', pairs)
          this.currencies = this.parseCurrencies(pairs)
          this.rates = this.parseRates(pairs)
          this.limits = this.parseLimits(pairs, this.rates)
          this.fees = this.parseFees(pairs)
          console.log('got rates ', this.rates)

          // init UI
          // console.log('this.currencies ', this.currencies)
          // this.formDialog.data.base = this.currencies[1]
          // this.formDialog.data.quote = this.currencies[2]
          // this.formDialog.data.baseAmount = 0.0001

        } catch (error) {
          this.$q.notify({
            message: `Failed to get pairs from boltz API: ${error.message}`,
            timeout: 1000
          })
        }
      },
      parseCurrencies: function (pairs) {
        const currencies = [];

        //orig
        const pushCurrency = currency => {
          if (!currencies.includes(currency)) {
            currencies.push(currency);
            if (currency === 'BTC') currencies.push(`${currency} ⚡`);
          }
        };

        Object.keys(pairs).forEach(id => {
          const { base, quote } = this.splitPairId(id);

          pushCurrency(base);
          pushCurrency(quote);
        });

        return currencies;
      },
      parseRates: function (pairs) {
        const rates = {};

        Object.keys(pairs).forEach(id => {
          const pair = pairs[id];

          // Set the rate for a sell order
          rates[id] = {
            pair: id,
            rate: pair.rate,
            orderSide: 'sell',
          };

          // And for a buy order
          const { base, quote } = this.splitPairId(id);

          if (base !== quote) {
            rates[`${quote}/${base}`] = {
              pair: id,
              rate: 1 / pair.rate,
              orderSide: 'buy',
            };
          }
        });

        return rates;
      },
      parseLimits: function (pairs, rates) {
        const limits = {};

        Object.keys(pairs).forEach(id => {
          const pair = pairs[id];
          const { base, quote } = this.splitPairId(id);

          if (base !== quote) {
            const reverseId = `${quote}/${base}`;
            const reverseRate = rates[reverseId].rate;

            limits[reverseId] = pair.limits;

            limits[id] = {
              minimal: Math.round(pair.limits.minimal * reverseRate),
              maximal: Math.round(pair.limits.maximal * reverseRate),
            };
          } else {
            limits[id] = pair.limits;
          }
        });

        return limits;
      },
      parseFees: function (pairs) {
        const minerFees = {};
        const percentages = {};

        Object.keys(pairs).forEach(id => {
          const fees = pairs[id].fees;
          const percentage = fees.percentage / 100;

          const { base, quote } = this.splitPairId(id);

          percentages[id] = percentage;
          minerFees[base] = fees.minerFees.baseAsset;

          if (base !== quote) {
            percentages[`${quote}/${base}`] = percentage;

            minerFees[quote] = fees.minerFees.quoteAsset;
          }
        });

        return {
          minerFees,
          percentages,
        };
      },
      splitPairId: function(pairId) {
        const split = pairId.split('/');

        return {
          base: split[0],
          quote: split[1],
        };
      },
      initScripts: function () {

        // web3modal
        const Web3Modal = window.Web3Modal.default
        const WalletConnectProvider = window.WalletConnectProvider.default
        const Fortmatic = window.Fortmatic
        const evmChains = window.evmChains

        // Check that the web page is run in a secure context,
        // as otherwise MetaMask won't be available
        // if(location.protocol !== 'https:') {
        //   document.querySelector("#connectButton").setAttribute("disabled", "disabled")
        //   return
        // }

        // Tell Web3modal what providers we have available.
        // Built-in web browser provider (only one can exist as a time)
        // like MetaMask, Brave or Opera is added automatically by Web3modal
        const providerOptions = {
          walletconnect: {
            package: WalletConnectProvider,
            options: {
              rpc: {
                30: 'https://public-node.rsk.co', // use RSK public nodes to connect
                33: 'https://4444-pseudozach-lnsovbridge-y4g21lh37m8.ws-us47.gitpod.io', // gitpod node for testing
              },
              infuraId: "8043bb2cf99347b1bfadfb233c5325c0",
            }
          },

          fortmatic: {
            package: Fortmatic,
            options: {
              key: "pk_test_391E26A3B43A3350"
            }
          },
        }

        web3Modal = new Web3Modal({
          cacheProvider: false, // optional
          providerOptions, // required
          disableInjectedProvider: false, // optional. For MetaMask / Brave / Opera.
        })

        // console.log("Web3Modal instance is", web3Modal)
      },
      /**
       * Connect wallet button pressed.
       */
      onConnect: async function () {

        console.log("Opening a dialog", web3Modal);
        try {
          this.provider = await web3Modal.connect();
        } catch(e) {
          console.log("Could not get a wallet connection", e);
          return;
        }

        // Subscribe to accounts change
        this.provider.on("accountsChanged", (accounts) => {
          this.fetchAccountData();
        });

        // Subscribe to chainId change
        this.provider.on("chainChanged", (chainId) => {
          // console.log('chainChanged to ', chainId)
          this.fetchAccountData();
        });

        // Subscribe to networkId change
        this.provider.on("networkChanged", (networkId) => {
          this.fetchAccountData();
        });

        await this.refreshAccountData();
      },
      /**
      * Disconnect wallet button pressed.
      */
      onDisconnect: async function () {

        console.log("Killing the wallet connection", this.provider);

        // TODO: Which providers have close method?
        if(this.provider.close) {
          await this.provider.close();

          // If the cached provider is not cleared,
          // WalletConnect will default to the existing session
          // and does not allow to re-scan the QR code with a new wallet.
          // Depending on your use case you may want or want not his behavir.
          await this.web3Modal.clearCachedProvider();
          this.provider = null;
        }

        this.selectedAccount = null;

        // Set the UI back to the initial state
        // document.querySelector("#prepare").style.display = "block";
        // document.querySelector("#connected").style.display = "none";
      },
      /**
       * Kick in the UI action after Web3modal dialog has chosen a provider
       */
      fetchAccountData: async function () {

        // Get a Web3 instance for the wallet
        const web3 = new Web3(this.provider);

        // console.log("Web3 instance is", web3);

        // // Get connected chain id from Ethereum node
        // const chainId = await web3.eth.getChainId();
        // console.log('chainId ', chainId)
        // // Load chain information over an HTTP API
        // const chainData = window.evmChains.getChain(chainId);
        // console.log('chainId ', window.evmChains, chainData)
        // // document.querySelector("#network-name").textContent = chainData.name;

        // Get list of accounts of the connected wallet
        const accounts = await web3.eth.getAccounts();

        // MetaMask does not give you all accounts, only the selected account
        this.selectedAccount = accounts[0];
        this.$q.notify({
          message: `Wallet connected: ${this.selectedAccount}`,
          timeout: 700
        })

        // document.querySelector("#selected-account").textContent = selectedAccount;

        // Get a handl
        // const template = document.querySelector("#template-balance");
        // const accountContainer = document.querySelector("#accounts");

        // Purge UI elements any previously loaded accounts
        // accountContainer.innerHTML = '';

        // Go through all accounts and get their ETH balance
        const rowResolvers = accounts.map(async (address) => {
          const balance = await web3.eth.getBalance(address);
          // ethBalance is a BigNumber instance
          // https://github.com/indutny/bn.js/
          const ethBalance = web3.utils.fromWei(balance, "ether");
          const humanFriendlyBalance = parseFloat(ethBalance).toFixed(4);
          console.log('humanFriendlyBalance ', address, humanFriendlyBalance)
          this.userBalances = {'RBTC': humanFriendlyBalance};
          // Fill in the templated row and put in the document
          // const clone = template.content.cloneNode(true);
          // clone.querySelector(".address").textContent = address;
          // clone.querySelector(".balance").textContent = humanFriendlyBalance;
          // accountContainer.appendChild(clone);
        });

        // Because rendering account does its own RPC commucation
        // with Ethereum node, we do not want to display any results
        // until data for all accounts is loaded
        await Promise.all(rowResolvers);

        // Display fully loaded UI for wallet data
        // document.querySelector("#prepare").style.display = "none";
        // document.querySelector("#connected").style.display = "block";
      },
      /**
      * Fetch account data for UI when
      * - User switches accounts in wallet
      * - User switches networks in wallet
      * - User connects wallet initially
      */
      refreshAccountData: async function () {

        // If any current data is displayed when
        // the user is switching acounts in the wallet
        // immediate hide this data
        // document.querySelector("#connected").style.display = "none";
        // document.querySelector("#prepare").style.display = "block";

        // Disable button while UI is loading.
        // fetchAccountData() will take a while as it communicates
        // with Ethereum node via JSON-RPC and loads chain data
        // over an API call.
        // document.querySelector("#btn-connect").setAttribute("disabled", "disabled")
        await this.fetchAccountData(this.provider);
        // document.querySelector("#btn-connect").removeAttribute("disabled")
      },
      // boltz extension methods
      getLimits() {
        const cfg = this.boltzConfig.data;
        if (cfg) {
          return {
            min: cfg.limits.minimal,
            max: cfg.limits.maximal
          };
        }
        return {
          min: 0,
          max: 0
        };
     },
     amountLabel() {
        let limits = this.getLimits();
        return "min: ("+limits.min+"), max: ("+limits.max+")";
     },
     disableSubmarineSwapDialog() {
        const data = this.submarineSwapDialog.data;
        let limits = this.getLimits();
        return data.wallet == null
            || data.amount < limits.min
            || data.amount > limits.max;
      },
      disableReverseSubmarineSwapDialog() {
        const data = this.reverseSubmarineSwapDialog.data;
        let limits = this.getLimits();
        return data.onchain_address == null
            || data.onchain_address.search(/^(bcrt1|bc1|[13])[a-zA-HJ-NP-Z0-9]{25,39}$/) !== 0
            || data.wallet == null
            || data.amount < limits.min
            || data.amount > limits.max;
      },
      downloadRefundFile(swapId) {
        let swap = _.findWhere(this.submarineSwaps, {id: swapId})
        let json = {
          "id": swap.boltz_id,
          "currency": "BTC",
          "redeemScript": swap.redeem_script,
          "privateKey": swap.refund_privkey,
          "timeoutBlockHeight": swap.timeout_block_height
        };
        let hiddenElement = document.createElement('a');
        hiddenElement.href = 'data:application/json;charset=utf-8,' + encodeURI(JSON.stringify(json));
        hiddenElement.target = '_blank';
        hiddenElement.download = 'boltz-refund-'+swap.boltz_id+'.json';
        hiddenElement.click();
      },
      refundSwap(swapId) {
        let url = '/swap/api/v1/submarineswap-refund/'+swapId
        LNbits.api
          .request('GET', url)
          .then(res => {
            this.resetStatusDialog()
          })
          .catch(error => {
            console.log("error", error);
            LNbits.utils.notifyApiError(error)
          });
      },
      openMempool(swap_id) {
        var swap = _.findWhere(this.submarineSwaps, {id: swap_id})
        if (swap === undefined) {
          var swap = _.findWhere(this.reverseSubmarineSwaps, {id: swap_id})
          var address = swap.lockup_address;
        }
        else {
          var address = swap.address;
        }
        window.open(this.mempool+"/address/"+address, "_blank");
      },
      openExplorer() {
        if(!this.selectedAccount) return
        window.open(this.explorerLink+"/address/"+this.selectedAccount.toLowerCase(), "_blank");
      },
      openStatusDialog(swap_id, reverse) {
        let url = '/swap/api/v1/swap-status/'+swap_id
        LNbits.api
          .request('GET', url)
          .then(res => {
            this.resetStatusDialog()
            this.statusDialog.data = {
              reverse: reverse,
              swap_id: swap_id,
              boltz: res.data.boltz,
              mempool: res.data.mempool,
              timeout_block_height: res.data.timeout_block_height,
              date: new Date().toUTCString(),
            };
            this.statusDialog.show = true;
          })
          .catch(error => {
            console.log("error", error);
            LNbits.utils.notifyApiError(error)
          });
      },
      openQrCodeDialog(submarineSwapId) {
        var swap = _.findWhere(this.submarineSwaps, {id: submarineSwapId})
        if (swap === undefined) {
          return console.assert("swap is undefined, this should not happen");
        }
        console.log('swap data: ', swap)
        this.qrCodeDialog.data = {
          id: swap.id,
          expected_amount: swap.expected_amount,
          expected_amount_btc: swap.expected_amount / 100000000,
          bip21: swap.bip21,
          address: swap.address,
          swap: swap,
        }
        this.qrCodeDialog.show = true
      },
      resetStatusDialog(){
        this.statusDialog = {
          show: false,
          data: {}
        }
      },
      resetAllStatusDialog(){
        this.allStatusDialog = {
          show: false,
          data: {}
        }
      },
      resetSubmarineSwapDialog(){
        this.submarineSwapDialog = {
          show: false,
          data: {}
        }
      },
      resetReverseSubmarineSwapDialog(){
        this.reverseSubmarineSwapDialog = {
          show: false,
          data: {}
        }
      },
      sendReverseSubmarineSwapFormData() {
        let wallet = _.findWhere(this.g.user.wallets, {
          id: this.reverseSubmarineSwapDialog.data.wallet
        })
        let data = this.reverseSubmarineSwapDialog.data;
        this.createReverseSubmarineSwap(wallet, data)
      },
      sendSubmarineSwapFormData() {
        let wallet = _.findWhere(this.g.user.wallets, {
          id: this.submarineSwapDialog.data.wallet
        })
        let data = this.submarineSwapDialog.data;

        if (data.id) {
          this.updateSwapOut(wallet, data)
        } else {
          this.createSubmarineSwap(wallet, data)
        }
      },
      exportSubmarineSwapCSV() {
        LNbits.utils.exportCSV(this.submarineSwapTable.columns, this.submarineSwaps)
      },
      exportReverseSubmarineSwapCSV() {
        LNbits.utils.exportCSV(this.reverseSubmarineSwapTable.columns, this.reverseSubmarineSwaps)
      },
      async createSubmarineSwap(wallet, data){
        try {
          const res = await LNbits.api.request('POST', '/swap/api/v1/submarineswap', this.g.user.wallets[0].adminkey, data)
          this.submarineSwaps.unshift(res.data);
          this.resetSubmarineSwapDialog();
          this.openQrCodeDialog(res.data.id);
          return res.data;
        } catch (error) {
          LNbits.utils.notifyApiError(error);
        }
      },
      async createReverseSubmarineSwap(wallet, data) {
        try {
          const response = await LNbits.api.request('POST', '/swap/api/v1/reverse-submarineswap', this.g.user.wallets[0].adminkey, data)
          console.log('response.data ', response.data)
          this.reverseSubmarineSwaps.unshift(response.data);
          this.resetReverseSubmarineSwapDialog();
          return response.data;
        } catch (error) {
          LNbits.utils.notifyApiError(error);
        }
      },
      getSubmarineSwap(){
        LNbits.api
          .request(
            'GET',
            '/swap/api/v1/submarineswap?all_wallets=true',
            this.g.user.wallets[0].inkey
          )
          .then(response => {
            this.submarineSwaps = response.data
          })
          .catch(function (error) {
            LNbits.utils.notifyApiError(error)
          })
      },
      getReverseSubmarineSwap(){
        LNbits.api
          .request(
            'GET',
            '/swap/api/v1/reverse-submarineswap?all_wallets=true',
            this.g.user.wallets[0].inkey
          )
          .then(response => {
            this.reverseSubmarineSwaps = response.data
          })
          .catch(function (error) {
            LNbits.utils.notifyApiError(error)
          })
      },
      getMempool(){
        LNbits.api.request('GET', '/swap/api/v1/mempool-url')
          .then(res => {
            this.mempool = res.data;
          })
          .catch(error => {
            console.log("error", error);
            LNbits.utils.notifyApiError(error)
          });
      },
      async getBoltzUrl(){
        try {
          this.boltzApi = (await LNbits.api.request('GET', '/swap/api/v1/boltz-url')).data
        } catch (error) {
          console.log("error", error);
          LNbits.utils.notifyApiError(error)
        }
      },
      getBoltzConfig(){
        LNbits.api.request('GET', '/swap/api/v1/boltz-config')
          .then(res => {
            this.boltzConfig = res;
          })
          .catch(error => {
            console.log("error", error);
            LNbits.utils.notifyApiError(error)
          });
      },
      checkSwaps(){
        LNbits.api.request('GET', '/swap/api/v1/check-swaps?all_wallets=true', this.g.user.wallets[0].inkey)
          .then(res => {
            this.allStatusDialog.data = {
              swaps: res.data
            };
            console.log(this.allStatusDialog);
            this.allStatusDialog.show = true;
          })
          .catch(error => {
            console.log("error", error);
            LNbits.utils.notifyApiError(error)
          });
      },
    }
  })
</script>
{% endblock %}
